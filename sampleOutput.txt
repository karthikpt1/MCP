from mcp.server.fastmcp import FastMCP
import requests
import os
import re
from pydantic import BaseModel
from urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter

# ------------------ Pydantic Models ------------------

class PostApiV1AuthorsRequest(BaseModel):

    id: int

    idBook: int

    firstName: str

    lastName: str



# --------- HTTP Resilience: Session with Retry Strategy ---------
def _create_session_with_retries():
    session = requests.Session()
    retry_strategy = Retry(
        total=3,
        backoff_factor=0.5,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=["GET", "POST", "PUT", "DELETE", "PATCH"]
    )
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    return session

_session = _create_session_with_retries()
# -------------------------------------------------------------------

# Initialize FastMCP Server: MyAPI
mcp = FastMCP("MyAPI")


@mcp.tool()
def get_api_v1_Authors():
    """GET /api/v1/Authors"""

    args_dict = {  }

    base_url = "/api/v1/Authors"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "GET".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.get(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def post_api_v1_Authors(body: PostApiV1AuthorsRequest):
    """POST /api/v1/Authors"""

    args_dict = { "body": body }

    base_url = "/api/v1/Authors"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    
    body_data = remaining_args.pop("body")
    
    payload = PostApiV1AuthorsRequest(**body_data).dict() if isinstance(body_data, dict) else body_data.dict()
    
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "POST".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.post(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}



@mcp.prompt()
def get_api_v1_Authors():
    """Auto-generated prompt for get_api_v1_Authors"""
    return f"""**1. Summarize output intent:** Summarize the expected output of a successful GET /api/v1/Authors request, including the format and structure of the response data. **2. Analyze possible errors and how to handle them:** Identify potential errors that may occur when making a GET /api/v1/Authors request and provide guidance on how to handle or troubleshoot each error. **3. Compare results or give context to output:** Explain how the results of a GET /api/v1/Authors request can be used in the context of an application, including how the data can be utilized and any potential limitations or considerations."""


@mcp.prompt()
def post_api_v1_Authors():
    """Auto-generated prompt for post_api_v1_Authors"""
    return f"""**1. Summarize output intent:** Describe the expected output of a successful POST /api/v1/Authors request, including the format and structure of the response data and any created resources. **2. Analyze possible errors and how to handle them:** Identify potential errors that may occur when making a POST /api/v1/Authors request and provide guidance on how to handle or troubleshoot each error, including error codes, messages, and any required corrective actions. **3. Compare results or give context to output:** Explain how the results of a POST /api/v1/Authors request can be used in the context of an application, including how the created resource can be utilized and any potential limitations or considerations."""


if __name__ == "__main__":
    mcp.run()