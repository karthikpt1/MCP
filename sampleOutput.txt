from mcp.server.fastmcp import FastMCP
import requests
import os
import re
from pydantic import BaseModel
from urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter

# ------------------ Pydantic Models ------------------

class PostApiV1ActivitiesRequest(BaseModel):

    id: int

    title: str

    dueDate: str

    completed: bool



class PutApiV1ActivitiesIdRequest(BaseModel):

    id: int

    title: str

    dueDate: str

    completed: bool



class PostApiV1AuthorsRequest(BaseModel):

    id: int

    idBook: int

    firstName: str

    lastName: str



class PutApiV1AuthorsIdRequest(BaseModel):

    id: int

    idBook: int

    firstName: str

    lastName: str



class PostApiV1BooksRequest(BaseModel):

    id: int

    title: str

    description: str

    pageCount: int

    excerpt: str

    publishDate: str



class PutApiV1BooksIdRequest(BaseModel):

    id: int

    title: str

    description: str

    pageCount: int

    excerpt: str

    publishDate: str



class PostApiV1CoverphotosRequest(BaseModel):

    id: int

    idBook: int

    url: str



class PutApiV1CoverphotosIdRequest(BaseModel):

    id: int

    idBook: int

    url: str



class PostApiV1UsersRequest(BaseModel):

    id: int

    userName: str

    password: str



class PutApiV1UsersIdRequest(BaseModel):

    id: int

    userName: str

    password: str



# --------- HTTP Resilience: Session with Retry Strategy ---------
def _create_session_with_retries():
    session = requests.Session()
    retry_strategy = Retry(
        total=3,
        backoff_factor=0.5,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=["GET", "POST", "PUT", "DELETE", "PATCH"]
    )
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    return session

_session = _create_session_with_retries()
# -------------------------------------------------------------------

# Initialize FastMCP Server: MyAPI
mcp = FastMCP("MyAPI")


@mcp.tool()
def get_api_v1_Activities():
    """GET /api/v1/Activities"""

    args_dict = {  }

    base_url = "/api/v1/Activities"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "GET".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.get(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def post_api_v1_Activities(body: PostApiV1ActivitiesRequest):
    """POST /api/v1/Activities"""

    args_dict = { "body": body }

    base_url = "/api/v1/Activities"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    
    body_data = remaining_args.pop("body")
    
    payload = PostApiV1ActivitiesRequest(**body_data).dict() if isinstance(body_data, dict) else body_data.dict()
    
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "POST".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.post(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def get_api_v1_Activities_id(id: int):
    """GET /api/v1/Activities/{id}"""

    args_dict = { "id": id }

    base_url = "/api/v1/Activities/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "GET".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.get(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def put_api_v1_Activities_id(id: int, body: PutApiV1ActivitiesIdRequest):
    """PUT /api/v1/Activities/{id}"""

    args_dict = { "id": id, "body": body }

    base_url = "/api/v1/Activities/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    
    body_data = remaining_args.pop("body")
    
    payload = PutApiV1ActivitiesIdRequest(**body_data).dict() if isinstance(body_data, dict) else body_data.dict()
    
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "PUT".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.put(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def delete_api_v1_Activities_id(id: int):
    """DELETE /api/v1/Activities/{id}"""

    args_dict = { "id": id }

    base_url = "/api/v1/Activities/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "DELETE".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.delete(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def get_api_v1_Authors():
    """GET /api/v1/Authors"""

    args_dict = {  }

    base_url = "/api/v1/Authors"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "GET".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.get(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def post_api_v1_Authors(body: PostApiV1AuthorsRequest):
    """POST /api/v1/Authors"""

    args_dict = { "body": body }

    base_url = "/api/v1/Authors"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    
    body_data = remaining_args.pop("body")
    
    payload = PostApiV1AuthorsRequest(**body_data).dict() if isinstance(body_data, dict) else body_data.dict()
    
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "POST".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.post(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def get_api_v1_Authors_authors_books_idBook(idBook: int):
    """GET /api/v1/Authors/authors/books/{idBook}"""

    args_dict = { "idBook": idBook }

    base_url = "/api/v1/Authors/authors/books/{idBook}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "GET".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.get(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def get_api_v1_Authors_id(id: int):
    """GET /api/v1/Authors/{id}"""

    args_dict = { "id": id }

    base_url = "/api/v1/Authors/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "GET".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.get(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def put_api_v1_Authors_id(id: int, body: PutApiV1AuthorsIdRequest):
    """PUT /api/v1/Authors/{id}"""

    args_dict = { "id": id, "body": body }

    base_url = "/api/v1/Authors/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    
    body_data = remaining_args.pop("body")
    
    payload = PutApiV1AuthorsIdRequest(**body_data).dict() if isinstance(body_data, dict) else body_data.dict()
    
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "PUT".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.put(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def delete_api_v1_Authors_id(id: int):
    """DELETE /api/v1/Authors/{id}"""

    args_dict = { "id": id }

    base_url = "/api/v1/Authors/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "DELETE".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.delete(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def get_api_v1_Books():
    """GET /api/v1/Books"""

    args_dict = {  }

    base_url = "/api/v1/Books"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "GET".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.get(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def post_api_v1_Books(body: PostApiV1BooksRequest):
    """POST /api/v1/Books"""

    args_dict = { "body": body }

    base_url = "/api/v1/Books"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    
    body_data = remaining_args.pop("body")
    
    payload = PostApiV1BooksRequest(**body_data).dict() if isinstance(body_data, dict) else body_data.dict()
    
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "POST".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.post(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def get_api_v1_Books_id(id: int):
    """GET /api/v1/Books/{id}"""

    args_dict = { "id": id }

    base_url = "/api/v1/Books/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "GET".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.get(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def put_api_v1_Books_id(id: int, body: PutApiV1BooksIdRequest):
    """PUT /api/v1/Books/{id}"""

    args_dict = { "id": id, "body": body }

    base_url = "/api/v1/Books/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    
    body_data = remaining_args.pop("body")
    
    payload = PutApiV1BooksIdRequest(**body_data).dict() if isinstance(body_data, dict) else body_data.dict()
    
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "PUT".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.put(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def delete_api_v1_Books_id(id: int):
    """DELETE /api/v1/Books/{id}"""

    args_dict = { "id": id }

    base_url = "/api/v1/Books/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "DELETE".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.delete(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def get_api_v1_CoverPhotos():
    """GET /api/v1/CoverPhotos"""

    args_dict = {  }

    base_url = "/api/v1/CoverPhotos"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "GET".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.get(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def post_api_v1_CoverPhotos(body: PostApiV1CoverphotosRequest):
    """POST /api/v1/CoverPhotos"""

    args_dict = { "body": body }

    base_url = "/api/v1/CoverPhotos"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    
    body_data = remaining_args.pop("body")
    
    payload = PostApiV1CoverphotosRequest(**body_data).dict() if isinstance(body_data, dict) else body_data.dict()
    
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "POST".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.post(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def get_api_v1_CoverPhotos_books_covers_idBook(idBook: int):
    """GET /api/v1/CoverPhotos/books/covers/{idBook}"""

    args_dict = { "idBook": idBook }

    base_url = "/api/v1/CoverPhotos/books/covers/{idBook}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "GET".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.get(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def get_api_v1_CoverPhotos_id(id: int):
    """GET /api/v1/CoverPhotos/{id}"""

    args_dict = { "id": id }

    base_url = "/api/v1/CoverPhotos/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "GET".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.get(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def put_api_v1_CoverPhotos_id(id: int, body: PutApiV1CoverphotosIdRequest):
    """PUT /api/v1/CoverPhotos/{id}"""

    args_dict = { "id": id, "body": body }

    base_url = "/api/v1/CoverPhotos/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    
    body_data = remaining_args.pop("body")
    
    payload = PutApiV1CoverphotosIdRequest(**body_data).dict() if isinstance(body_data, dict) else body_data.dict()
    
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "PUT".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.put(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def delete_api_v1_CoverPhotos_id(id: int):
    """DELETE /api/v1/CoverPhotos/{id}"""

    args_dict = { "id": id }

    base_url = "/api/v1/CoverPhotos/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "DELETE".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.delete(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def get_api_v1_Users():
    """GET /api/v1/Users"""

    args_dict = {  }

    base_url = "/api/v1/Users"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "GET".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.get(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def post_api_v1_Users(body: PostApiV1UsersRequest):
    """POST /api/v1/Users"""

    args_dict = { "body": body }

    base_url = "/api/v1/Users"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    
    body_data = remaining_args.pop("body")
    
    payload = PostApiV1UsersRequest(**body_data).dict() if isinstance(body_data, dict) else body_data.dict()
    
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "POST".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.post(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def get_api_v1_Users_id(id: int):
    """GET /api/v1/Users/{id}"""

    args_dict = { "id": id }

    base_url = "/api/v1/Users/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "GET".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.get(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def put_api_v1_Users_id(id: int, body: PutApiV1UsersIdRequest):
    """PUT /api/v1/Users/{id}"""

    args_dict = { "id": id, "body": body }

    base_url = "/api/v1/Users/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    
    body_data = remaining_args.pop("body")
    
    payload = PutApiV1UsersIdRequest(**body_data).dict() if isinstance(body_data, dict) else body_data.dict()
    
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "PUT".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.put(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}


@mcp.tool()
def delete_api_v1_Users_id(id: int):
    """DELETE /api/v1/Users/{id}"""

    args_dict = { "id": id }

    base_url = "/api/v1/Users/{id}"
    remaining_args = args_dict.copy()

    path_params = re.findall(r"{(.*?)}", base_url)
    for param in path_params:
        if param in remaining_args:
            base_url = base_url.replace("{" + param + "}", str(remaining_args.pop(param)))

    headers = {}
    

    payload = None
    

    # Send remaining args as query params for GET, or for other methods if they exist
    query_params = remaining_args if remaining_args else None

    try:
        # Only send json payload for POST/PUT/PATCH/DELETE, not for GET
        method_lower = "DELETE".lower()
        request_kwargs = {
            "params": query_params,
            "headers": headers,
            "timeout": 15
        }
        
        # For regular JSON payloads, use json parameter
        if method_lower in ["post", "put", "patch", "delete"] and payload is not None:
            request_kwargs["json"] = payload
        
        
        response = _session.delete(base_url, **request_kwargs)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e), "url_attempted": base_url}



@mcp.prompt()
def summarize(id):
    """Prompt"""
    return f"""Summarize the result"""


if __name__ == "__main__":
    mcp.run()